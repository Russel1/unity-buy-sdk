namespace <%= namespace %> {
    using System;
    using System.Collections.Generic;
    using System.Text;
    using <%= namespace %>.SDK;
    using <%= namespace %>.GraphQL;

    #if UNITY_IOS
    using <%= namespace %>.SDK.iOS;
    #endif

    /// <summary>
    /// This exception is thrown when interacting with a cart to add, update, or delete line items and no matching
    /// variant could be found.
    /// </summary>
    public class NoMatchingVariantException : Exception {
        public NoMatchingVariantException(string message) : base(message) {}
    }
    
    // Public API

    /// <summary>
    /// Manages line items for an order. Can also be used to generate a web checkout link to check out in browser.
    /// </summary>
    public partial class Cart {
        /// <summary>
        /// Current <see ref="CartLineItems">line items </see> for this <see ref="Cart">Cart </see>.
        /// </summary>
        public CartLineItems LineItems {
            get {
                return _LineItems;
            }
        }

        public List<UserError> UserErrors {
            get {
                return _UserErrors;
            }
        }

        private bool IsSaved {
            get {
                return IsCreated && LineItems.IsSaved;
            }
        }

        private bool IsCreated {
            get {
                return CurrentCheckout != null;
            }
        }

        public Checkout CurrentCheckout { get; private set; }

        private const float POLL_DELAY_SECONDS = 0.5f;
        private CartLineItems _LineItems;
        private List<UserError> _UserErrors = null;
        private List<String> DeletedLineItems = new List<string>();
        private ShopifyClient Client;

        private IWebCheckout WebCheckout;
        private INativeCheckout NativeCheckout;
        private CheckoutMutator CheckoutMutator;

        private CheckoutPoller CheckoutPoller;
        private PaymentPoller PaymentPoller;

        /// <summary>
        /// Constructs a new cart using a <see ref="ShopifyClient">ShopifyClient </see>. Typically, carts won't be
        /// instantiated directly, but will rather be instatiated using <see ref="ShopifyClient.Cart">ShopifyBuy.Client().Cart() </see>.
        /// </summary>
        /// <param name="client">client associated with this cart</param>
        /// \code
        /// // Example that creates a cart using a ShopifyClient and checks how many line items it has
        /// // (spoiler: it has 0 line items since the cart was just created).
        /// ShopifyClient client = new ShopifyClient(accessToken, shopDomain);
        ///
        /// Cart cart = new Cart(client);
        ///
        /// Debug.Log(cart.LineItems.All().Count);
        /// \endcode
        public Cart(ShopifyClient client) {
            Client = client;
            _LineItems = new CartLineItems(OnDeleteLineItem);

            CheckoutMutator = new CheckoutMutator(client, DidMutateCheckout);
            CheckoutPoller = new CheckoutPoller(client, DidMutateCheckout);
            PaymentPoller = new PaymentPoller(client);

            #if UNITY_IOS
            WebCheckout = new iOSWebCheckout(this, Client);
            NativeCheckout = new iOSNativeCheckout(CheckoutMutator);
            #endif
        }

        #region Public API

        public void GetWebCheckoutLink(GetWebCheckoutLinkSuccess success, GetWebCheckoutLinkFailure failure) {
            CheckoutSave(error => {
                if (error != null) {
                    failure(error);
                    return;
                }

                success(CurrentCheckout.webUrl());
            });
        }

        /// <summary>
        /// Launches a platform-specific web view screen with the Cart's web checkout link loaded. This can be used to perform
        /// a cart checkout from within your application instead of being directed to an external web application. Typically this
        /// can be used as a fallback measure in cases where the user's device doesn't support native pay methods.
        /// </summary>
        /// <param name="success">called when the web checkout screen has been dismissed and the checkout was successful.</param>
        /// <param name="cancelled">called when the web checkout screen was dismissed before completing a checkout.</param>
        /// <param name="failure">called when an error was encountered after the web checkout screen has been dismissed.</param>
        public void CheckoutWithNativeWebView(CheckoutSuccessCallback success, CheckoutCancelCallback cancelled, CheckoutFailureCallback failure) {
            if (WebCheckout == null) {
                throw new PlatformNotSupportedException("This platform does not support checkout with web pay");
            }

            GetWebCheckoutLink(url => {
                WebCheckout.Checkout(url, success, cancelled, failure);
            }, error => {
                failure(error);
            });
        }

        public void CheckoutWithNativePay(string key, CheckoutSuccessCallback success, CheckoutCancelCallback cancelled, CheckoutFailureCallback failure) {
            if (NativeCheckout == null) {
                throw new PlatformNotSupportedException("This platform does not support checkout with native pay");
            }

            CheckoutSave(error => {
                if (error != null) {
                    failure(error);
                } else {
                    NativeCheckout.Checkout(key, success, cancelled, failure);
                }
            });
        }

        public bool CanShowNativePaySetup() {
            if (NativeCheckout != null) {
               return  NativeCheckout.CanShowPaymentSetup();
            } else {
                return false;
            }
        }

        public void ShowNativePaySetup() {
            if (NativeCheckout != null) {
                NativeCheckout.ShowPaymentSetup();
            } else {
                throw new PlatformNotSupportedException("This platform does not support showing a native payment setup");
            }
        }

        public bool CanCheckoutWithNativePay() {
            if (NativeCheckout != null) {
                return NativeCheckout.CanCheckout();
            } else {
                return false;
            }
        }

        public void CheckoutWithTokenizedPayment(TokenizedPaymentInput tokenizedPaymentInput, CompletionCallback callback) {
            Action<Payment> pollPayment = (payment) => {
                PaymentPoller.PollPaymentReady(payment.id(), (Payment newPayment, ShopifyError error) => {
                    if (error != null) {
                        callback(error);
                        return;
                    } 

                    DidMutateCheckout(payment.checkout());
                    if (UserErrors.Count > 0) {
                        HandleUserError(callback);
                        return;
                    }

                    callback(null);
                });
            };

            Action checkoutWithTokenizedPayment = () => {
                MutationQuery query = new MutationQuery();
                DefaultQueries.checkout.CheckoutCompleteWithTokenizedPayment(query, CurrentCheckout.id(), tokenizedPaymentInput);

                Client.Mutation(query, (Mutation response, ShopifyError error) => {
                    if (error != null) {
                        callback(error);
                        return;
                    } 

                    var responseNode = response.checkoutCompleteWithTokenizedPayment();
                    var payment = responseNode.payment();

                    DidMutateCheckout(responseNode.checkout(), responseNode.userErrors());

                    if (UserErrors.Count > 0) {
                        HandleUserError(callback);
                        return;
                    }

                    if (payment.ready()) {
                        callback(null);
                    } else {
                        pollPayment(payment);
                    }
                });
            };

            // Ensure we can checkout first
            if (CurrentCheckout.ready()){
                checkoutWithTokenizedPayment();
                return;
            } 

            CheckoutPoller.PollCheckoutReady(CurrentCheckout.id(), (Checkout checkout, ShopifyError error) => {
                if (error != null) {
                    callback(error);
                    return;
                } 

                checkoutWithTokenizedPayment();
            });
        }

        public void CheckoutSave(CompletionCallback callback) {
            if (!IsCreated) {
                CreateCheckout(callback);
            } else if(!IsSaved) {
                UpdateCheckout(callback);
            } else {
                callback(null);
            }
        }

        #endregion

        #region Private Helpers

        private void CreateCheckout(CompletionCallback callback) {
            List<CheckoutLineItemInput> newLineItemInput = CartLineItems.ConvertToCheckoutLineItemInput(LineItems.All());
            CheckoutMutator.CreateCheckout(
                items: newLineItemInput,
                callback: callback
            );
        }

        private void UpdateCheckout(CompletionCallback callback) {
            // remove all line items them add them
            List<string> toRemove = CartLineItems.ConvertToLineItemIds(LineItems.All());
            toRemove.AddRange(DeletedLineItems);

            List<CheckoutLineItemInput> toAdd = CartLineItems.ConvertToCheckoutLineItemInput(LineItems.All());

            CheckoutMutator.UpdateItems(
                checkoutId: CurrentCheckout.id(),
                lineItemsToAdd: toAdd,
                lineItemsToRemove: toRemove,
                callback: (e) => {
                    DeletedLineItems.Clear();
                    callback(e);
                }
            );
        }

        private Checkout DidMutateCheckout(Checkout checkout) {
            return DidMutateCheckout(checkout, new List<UserError>());
        }

        /// <summary>
        /// Callback that is loaded onto the CheckoutMutator that is invoked whenever a change
        /// has been made on the checkout.
        /// </summary>
        /// <param name="checkout">New, mutated checkout from the server.</param>
        /// <param name="errors">User errors returned from the checkout mutation.</param>
        /// <returns></returns>
        private Checkout DidMutateCheckout(Checkout checkout, List<UserError> userErrors) {
            Checkout newCheckout;

            if (CurrentCheckout == null) {
                newCheckout = checkout;
            } else {
                MergeCheckout merger = new MergeCheckout();
                newCheckout = merger.Merge(CurrentCheckout, checkout);
            }

            if (userErrors.Count > 0) {
                _UserErrors = userErrors;
            } else {
                _UserErrors = null;
            }

            UpdateLineItemFromCheckout(newCheckout);
            CurrentCheckout = newCheckout;
            return newCheckout;
        }

        private void UpdateLineItemFromCheckout(Checkout checkout) {
            if (checkout == null) {
                return;
            }
        
            // sometimes we may not query line items for instance when polling is being performed
            try {
                List<CheckoutLineItem> lineItems = (List<CheckoutLineItem>) checkout.lineItems();
                LineItems.UpdateLineItemsFromCheckoutLineItems(lineItems);
            } catch(NoQueryException exception) {}
        }

        private void OnDeleteLineItem(string lineItemId) {
            DeletedLineItems.Add(lineItemId);
        }

        private void HandleUserError(CompletionCallback callback) {
            ShopifyError error = new ShopifyError(
                ShopifyError.ErrorType.UserError,
                "There were issues with some of the fields sent. See `cart.UserErrors`"
            );

            callback(error);
        }

        #endregion
    }
}
